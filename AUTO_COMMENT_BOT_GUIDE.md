# üéØ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –±–æ—Ç –¥–ª—è –æ—Ç–≤–µ—Ç–æ–≤ –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã –≤ Telegram –∫–∞–Ω–∞–ª–∞—Ö

## üìã –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ

1. [–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ —Å–∏—Å—Ç–µ–º—ã](#–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞-—Å–∏—Å—Ç–µ–º—ã)
2. [–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π —Å—Ç–µ–∫](#—Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π-—Å—Ç–µ–∫)
3. [–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞](#—Å—Ç—Ä—É–∫—Ç—É—Ä–∞-–ø—Ä–æ–µ–∫—Ç–∞)
4. [–ü–æ—à–∞–≥–æ–≤–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è](#–ø–æ—à–∞–≥–æ–≤–∞—è-—Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è)
5. [–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ –∞–Ω—Ç–∏-–±–∞–Ω –º–µ—Ä—ã](#–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å-–∏-–∞–Ω—Ç–∏-–±–∞–Ω-–º–µ—Ä—ã)
6. [–î–µ–ø–ª–æ–π –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥](#–¥–µ–ø–ª–æ–π-–∏-–º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥)

---

## üèó –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ —Å–∏—Å—Ç–µ–º—ã

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    AUTO COMMENT BOT                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ               ‚îÇ               ‚îÇ
           v               v               v
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Channel  ‚îÇ    ‚îÇ Comment  ‚îÇ    ‚îÇ  Reply   ‚îÇ
    ‚îÇ Monitor  ‚îÇ    ‚îÇ Analyzer ‚îÇ    ‚îÇ  Poster  ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ               ‚îÇ               ‚îÇ
           v               v               v
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ         PostgreSQL Database              ‚îÇ
    ‚îÇ  - channels                              ‚îÇ
    ‚îÇ  - posts                                 ‚îÇ
    ‚îÇ  - comments                              ‚îÇ
    ‚îÇ  - replies (–¥–ª—è –∞–Ω—Ç–∏-—Å–ø–∞–º–∞)             ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                           v
                   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                   ‚îÇ  Claude AI   ‚îÇ
                   ‚îÇ  (–¥–ª—è        ‚îÇ
                   ‚îÇ  –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏   ‚îÇ
                   ‚îÇ  –æ—Ç–≤–µ—Ç–æ–≤)    ‚îÇ
                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üõ† –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π —Å—Ç–µ–∫

### Backend
- **Swift 5.9** + **Vapor 4**
- **PostgreSQL** –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
- **Telegram Bot API** –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è
- **Claude AI API** –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–æ–≤

### –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ
- **Docker** –¥–ª—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∏–∑–∞—Ü–∏–∏
- **Railway/Fly.io** –¥–ª—è —Ö–æ—Å—Ç–∏–Ω–≥–∞
- **Redis** (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) –¥–ª—è –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è

---

## üìÅ –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞

```
telegram-comment-bot/
‚îú‚îÄ‚îÄ Package.swift
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ .env.example
‚îú‚îÄ‚îÄ README.md
‚îÇ
‚îú‚îÄ‚îÄ Sources/
‚îÇ   ‚îî‚îÄ‚îÄ App/
‚îÇ       ‚îú‚îÄ‚îÄ Application/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ main.swift
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ configure.swift
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ routes.swift
‚îÇ       ‚îÇ
‚îÇ       ‚îú‚îÄ‚îÄ Core/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ Models/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Channel.swift
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Post.swift
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Comment.swift
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Reply.swift
‚îÇ       ‚îÇ   ‚îÇ
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ Database/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Migrations/
‚îÇ       ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateChannels.swift
‚îÇ       ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreatePosts.swift
‚îÇ       ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateComments.swift
‚îÇ       ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CreateReplies.swift
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DatabaseConfig.swift
‚îÇ       ‚îÇ   ‚îÇ
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ Services/
‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ TelegramClient.swift
‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ ClaudeClient.swift
‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ Logger.swift
‚îÇ       ‚îÇ
‚îÇ       ‚îú‚îÄ‚îÄ Features/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ ChannelMonitor/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ChannelDiscoveryService.swift
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ChannelMonitorService.swift
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PostParserService.swift
‚îÇ       ‚îÇ   ‚îÇ
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ CommentAnalyzer/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CommentParserService.swift
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ QuestionDetectorService.swift
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ KeywordMatcher.swift
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SentimentAnalyzer.swift
‚îÇ       ‚îÇ   ‚îÇ
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ ReplyGenerator/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AIReplyService.swift
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TemplateEngine.swift
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ContextBuilder.swift
‚îÇ       ‚îÇ   ‚îÇ
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ ReplyPoster/
‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ CommentPosterService.swift
‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ AntiSpamService.swift
‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ RateLimiter.swift
‚îÇ       ‚îÇ
‚îÇ       ‚îî‚îÄ‚îÄ Jobs/
‚îÇ           ‚îú‚îÄ‚îÄ ChannelScanJob.swift
‚îÇ           ‚îú‚îÄ‚îÄ CommentAnalysisJob.swift
‚îÇ           ‚îî‚îÄ‚îÄ ReplyPostingJob.swift
‚îÇ
‚îî‚îÄ‚îÄ Tests/
    ‚îî‚îÄ‚îÄ AppTests/
        ‚îú‚îÄ‚îÄ ChannelMonitorTests.swift
        ‚îú‚îÄ‚îÄ CommentAnalyzerTests.swift
        ‚îî‚îÄ‚îÄ ReplyGeneratorTests.swift
```

---

## üöÄ –ü–æ—à–∞–≥–æ–≤–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è

### –®–∞–≥ 1: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ–µ–∫—Ç–∞

```bash
# –°–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç
mkdir telegram-comment-bot
cd telegram-comment-bot

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º Swift Package
swift package init --type executable

# –°–æ–∑–¥–∞—ë–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π
mkdir -p Sources/App/{Application,Core/{Models,Database/Migrations,Services},Features/{ChannelMonitor,CommentAnalyzer,ReplyGenerator,ReplyPoster},Jobs}
```

### –®–∞–≥ 2: Package.swift

```swift
// swift-tools-version:5.9
import PackageDescription

let package = Package(
    name: "telegram-comment-bot",
    platforms: [
        .macOS(.v13)
    ],
    dependencies: [
        // Vapor Framework
        .package(url: "https://github.com/vapor/vapor.git", from: "4.99.0"),
        
        // Fluent + PostgreSQL
        .package(url: "https://github.com/vapor/fluent.git", from: "4.9.0"),
        .package(url: "https://github.com/vapor/fluent-postgres-driver.git", from: "2.8.0"),
        
        // Queues –¥–ª—è —Ñ–æ–Ω–æ–≤—ã—Ö –∑–∞–¥–∞—á
        .package(url: "https://github.com/vapor/queues.git", from: "1.13.0"),
    ],
    targets: [
        .executableTarget(
            name: "App",
            dependencies: [
                .product(name: "Vapor", package: "vapor"),
                .product(name: "Fluent", package: "fluent"),
                .product(name: "FluentPostgresDriver", package: "fluent-postgres-driver"),
                .product(name: "Queues", package: "queues"),
            ]
        ),
        .testTarget(
            name: "AppTests",
            dependencies: [
                .target(name: "App"),
                .product(name: "XCTVapor", package: "vapor"),
            ]
        )
    ]
)
```

### –®–∞–≥ 3: –ú–æ–¥–µ–ª–∏ –¥–∞–Ω–Ω—ã—Ö

#### Channel.swift
```swift
import Fluent
import Vapor

final class Channel: Model, Content {
    static let schema = "channels"
    
    @ID(key: .id)
    var id: UUID?
    
    @Field(key: "username")
    var username: String // @aviasales
    
    @Field(key: "title")
    var title: String
    
    @Field(key: "category")
    var category: String // travel, finance, tech
    
    @Field(key: "subscribers_count")
    var subscribersCount: Int
    
    @Field(key: "is_active")
    var isActive: Bool
    
    @Field(key: "last_scanned_at")
    var lastScannedAt: Date?
    
    @Timestamp(key: "created_at", on: .create)
    var createdAt: Date?
    
    @Children(for: \.$channel)
    var posts: [Post]
    
    init() {}
    
    init(
        id: UUID? = nil,
        username: String,
        title: String,
        category: String,
        subscribersCount: Int = 0,
        isActive: Bool = true
    ) {
        self.id = id
        self.username = username
        self.title = title
        self.category = category
        self.subscribersCount = subscribersCount
        self.isActive = isActive
    }
}
```

#### Post.swift
```swift
import Fluent
import Vapor

final class Post: Model, Content {
    static let schema = "posts"
    
    @ID(key: .id)
    var id: UUID?
    
    @Parent(key: "channel_id")
    var channel: Channel
    
    @Field(key: "telegram_message_id")
    var telegramMessageId: Int
    
    @Field(key: "text")
    var text: String
    
    @Field(key: "views_count")
    var viewsCount: Int?
    
    @Field(key: "comments_count")
    var commentsCount: Int?
    
    @Field(key: "posted_at")
    var postedAt: Date
    
    @Timestamp(key: "created_at", on: .create)
    var createdAt: Date?
    
    @Children(for: \.$post)
    var comments: [Comment]
    
    init() {}
}
```

#### Comment.swift
```swift
import Fluent
import Vapor

final class Comment: Model, Content {
    static let schema = "comments"
    
    @ID(key: .id)
    var id: UUID?
    
    @Parent(key: "post_id")
    var post: Post
    
    @Field(key: "telegram_comment_id")
    var telegramCommentId: Int
    
    @Field(key: "author_username")
    var authorUsername: String?
    
    @Field(key: "author_first_name")
    var authorFirstName: String
    
    @Field(key: "text")
    var text: String
    
    @Field(key: "is_question")
    var isQuestion: Bool
    
    @Field(key: "keywords_matched")
    var keywordsMatched: [String]
    
    @Field(key: "sentiment_score")
    var sentimentScore: Double? // -1.0 to 1.0
    
    @Field(key: "replied")
    var replied: Bool
    
    @Timestamp(key: "created_at", on: .create)
    var createdAt: Date?
    
    @OptionalChild(for: \.$comment)
    var reply: Reply?
    
    init() {}
}
```

#### Reply.swift
```swift
import Fluent
import Vapor

final class Reply: Model, Content {
    static let schema = "replies"
    
    @ID(key: .id)
    var id: UUID?
    
    @Parent(key: "comment_id")
    var comment: Comment
    
    @Field(key: "generated_text")
    var generatedText: String
    
    @Field(key: "posted")
    var posted: Bool
    
    @Field(key: "telegram_reply_id")
    var telegramReplyId: Int?
    
    @Field(key: "posted_at")
    var postedAt: Date?
    
    @Timestamp(key: "created_at", on: .create)
    var createdAt: Date?
    
    init() {}
}
```

### –®–∞–≥ 4: –ú–∏–≥—Ä–∞—Ü–∏–∏

#### CreateChannels.swift
```swift
import Fluent

struct CreateChannels: AsyncMigration {
    func prepare(on database: Database) async throws {
        try await database.schema("channels")
            .id()
            .field("username", .string, .required)
            .field("title", .string, .required)
            .field("category", .string, .required)
            .field("subscribers_count", .int, .required)
            .field("is_active", .bool, .required)
            .field("last_scanned_at", .datetime)
            .field("created_at", .datetime)
            .unique(on: "username")
            .create()
    }
    
    func revert(on database: Database) async throws {
        try await database.schema("channels").delete()
    }
}
```

### –®–∞–≥ 5: Telegram Client

#### TelegramClient.swift
```swift
import Vapor

struct TelegramMessage: Codable {
    let messageId: Int
    let from: TelegramUser?
    let chat: TelegramChat
    let text: String?
    let date: Int
    
    enum CodingKeys: String, CodingKey {
        case messageId = "message_id"
        case from, chat, text, date
    }
}

struct TelegramUser: Codable {
    let id: Int
    let firstName: String
    let username: String?
    
    enum CodingKeys: String, CodingKey {
        case id
        case firstName = "first_name"
        case username
    }
}

struct TelegramChat: Codable {
    let id: Int
    let type: String
    let title: String?
    let username: String?
}

final class TelegramClient {
    private let client: Client
    private let botToken: String
    private let logger: Logger
    private let baseURL = "https://api.telegram.org"
    
    init(client: Client, botToken: String, logger: Logger) {
        self.client = client
        self.botToken = botToken
        self.logger = logger
    }
    
    // –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–∞–Ω–∞–ª–µ
    func getChat(username: String) async throws -> TelegramChat {
        let url = URI(string: "\(baseURL)/bot\(botToken)/getChat")
        
        var request = ClientRequest(method: .POST, url: url)
        request.headers.add(name: .contentType, value: "application/json")
        
        let body: [String: Any] = ["chat_id": "@\(username)"]
        request.body = .init(data: try JSONSerialization.data(withJSONObject: body))
        
        let response = try await client.send(request)
        
        struct Response: Codable {
            let ok: Bool
            let result: TelegramChat
        }
        
        let apiResponse = try response.content.decode(Response.self)
        return apiResponse.result
    }
    
    // –ü–æ–ª—É—á–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ –∫–∞–Ω–∞–ª–∞ (—á–µ—Ä–µ–∑ –ø–æ–∏—Å–∫)
    func getChannelPosts(username: String, limit: Int = 20) async throws -> [TelegramMessage] {
        // Telegram Bot API –Ω–µ –ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–∞–ø—Ä—è–º—É—é —á–∏—Ç–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ –ø—É–±–ª–∏—á–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤
        // –ù—É–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Telegram Client API (MTProto) –∏–ª–∏ —Å–¥–µ–ª–∞—Ç—å –±–æ—Ç–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º
        
        // –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –º–µ—Ç–æ–¥ —á–µ—Ä–µ–∑ getUpdates –µ—Å–ª–∏ –±–æ—Ç –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä
        let url = URI(string: "\(baseURL)/bot\(botToken)/getUpdates")
        
        var request = ClientRequest(method: .POST, url: url)
        request.headers.add(name: .contentType, value: "application/json")
        
        let body: [String: Any] = [
            "limit": limit,
            "allowed_updates": ["channel_post", "message"]
        ]
        request.body = .init(data: try JSONSerialization.data(withJSONObject: body))
        
        let response = try await client.send(request)
        
        struct Update: Codable {
            let updateId: Int
            let channelPost: TelegramMessage?
            let message: TelegramMessage?
            
            enum CodingKeys: String, CodingKey {
                case updateId = "update_id"
                case channelPost = "channel_post"
                case message
            }
        }
        
        struct Response: Codable {
            let ok: Bool
            let result: [Update]
        }
        
        let apiResponse = try response.content.decode(Response.self)
        return apiResponse.result.compactMap { $0.channelPost ?? $0.message }
    }
    
    // –û—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π (–æ—Ç–≤–µ—Ç –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ)
    func sendComment(
        chatId: String,
        replyToMessageId: Int,
        text: String
    ) async throws -> TelegramMessage {
        let url = URI(string: "\(baseURL)/bot\(botToken)/sendMessage")
        
        var request = ClientRequest(method: .POST, url: url)
        request.headers.add(name: .contentType, value: "application/json")
        
        let body: [String: Any] = [
            "chat_id": chatId,
            "text": text,
            "reply_to_message_id": replyToMessageId,
            "parse_mode": "HTML"
        ]
        request.body = .init(data: try JSONSerialization.data(withJSONObject: body))
        
        let response = try await client.send(request)
        
        guard response.status == .ok else {
            logger.error("‚ùå Telegram sendMessage error: \(response.status)")
            throw Abort(.internalServerError)
        }
        
        struct Response: Codable {
            let ok: Bool
            let result: TelegramMessage
        }
        
        let apiResponse = try response.content.decode(Response.self)
        logger.info("‚úÖ Comment posted: \(text.prefix(50))...")
        
        return apiResponse.result
    }
}
```

### –®–∞–≥ 6: Question Detector Service

#### QuestionDetectorService.swift
```swift
import Vapor

struct QuestionPattern {
    let keywords: [String]
    let category: String
    let weight: Double
}

final class QuestionDetectorService {
    private let logger: Logger
    
    // –ü–∞—Ç—Ç–µ—Ä–Ω—ã –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –≤–æ–ø—Ä–æ—Å–æ–≤ –æ –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏—è—Ö
    private let travelPatterns: [QuestionPattern] = [
        // –ü–æ–∏—Å–∫ –±–∏–ª–µ—Ç–æ–≤
        QuestionPattern(
            keywords: ["–≥–¥–µ –Ω–∞–π—Ç–∏", "–≥–¥–µ –∫—É–ø–∏—Ç—å", "–≥–¥–µ –∏—Å–∫–∞—Ç—å", "–∫–∞–∫ –Ω–∞–π—Ç–∏", "–≥–¥–µ –¥–µ—à–µ–≤–ª–µ"],
            category: "ticket_search",
            weight: 1.0
        ),
        QuestionPattern(
            keywords: ["–±–∏–ª–µ—Ç", "–∞–≤–∏–∞–±–∏–ª–µ—Ç", "–ø–µ—Ä–µ–ª—ë—Ç", "—Ä–µ–π—Å"],
            category: "tickets",
            weight: 0.8
        ),
        
        // –¶–µ–Ω—ã –∏ —Å–∫–∏–¥–∫–∏
        QuestionPattern(
            keywords: ["—Å–∫–æ–ª—å–∫–æ —Å—Ç–æ–∏—Ç", "–∫–∞–∫–∞—è —Ü–µ–Ω–∞", "–ø–æ–¥–µ—à–µ–≤–µ–µ—Ç", "—Å–∫–∏–¥–∫–∏", "–∞–∫—Ü–∏–∏"],
            category: "pricing",
            weight: 0.9
        ),
        
        // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        QuestionPattern(
            keywords: ["–∫—É–¥–∞", "–≤ –∫–∞–∫—É—é —Å—Ç—Ä–∞–Ω—É", "–∫–∞–∫–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ", "—á—Ç–æ –ø–æ—Å–æ–≤–µ—Ç—É–µ—Ç–µ"],
            category: "destinations",
            weight: 0.7
        ),
        
        // –°–µ—Ä–≤–∏—Å—ã –∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
        QuestionPattern(
            keywords: ["–∫–∞–∫–æ–π —Å–µ—Ä–≤–∏—Å", "–∫–∞–∫–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ", "–∫–∞–∫–æ–π —Å–∞–π—Ç", "–≥–¥–µ –ª—É—á—à–µ"],
            category: "services",
            weight: 1.0
        ),
        
        // –°–æ–≤–µ—Ç—ã
        QuestionPattern(
            keywords: ["–ø–æ—Å–æ–≤–µ—Ç—É–π—Ç–µ", "–ø–æ–¥—Å–∫–∞–∂–∏—Ç–µ", "–ø–æ–º–æ–≥–∏—Ç–µ", "–∫—Ç–æ –∑–Ω–∞–µ—Ç", "–º–æ–∂–µ—Ç –∫—Ç–æ"],
            category: "advice",
            weight: 0.9
        ),
        
        // –≠–∫–æ–Ω–æ–º–∏—è
        QuestionPattern(
            keywords: ["—ç–∫–æ–Ω–æ–º–∏—Ç—å", "—Å—ç–∫–æ–Ω–æ–º–∏—Ç—å", "–¥–µ—à–µ–≤–ª–µ", "–≤—ã–≥–æ–¥–Ω–æ", "–±—é–¥–∂–µ—Ç–Ω–æ"],
            category: "savings",
            weight: 0.8
        )
    ]
    
    init(logger: Logger) {
        self.logger = logger
    }
    
    // –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –≤–æ–ø—Ä–æ—Å–æ–º
    func isQuestion(_ text: String) -> Bool {
        let normalized = text.lowercased()
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –≤–æ–ø—Ä–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ –∑–Ω–∞–∫–∏
        if normalized.contains("?") {
            return true
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –≤–æ–ø—Ä–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ —Å–ª–æ–≤–∞ –≤ –Ω–∞—á–∞–ª–µ
        let questionWords = ["–≥–¥–µ", "–∫–∞–∫", "–∫–æ–≥–¥–∞", "–ø–æ—á–µ–º—É", "–∑–∞—á–µ–º", "–∫–∞–∫–æ–π", "–∫—Ç–æ", "—á—Ç–æ", "—Å–∫–æ–ª—å–∫–æ"]
        for word in questionWords {
            if normalized.hasPrefix(word + " ") {
                return true
            }
        }
        
        return false
    }
    
    // –ù–∞–π—Ç–∏ —Å–æ–≤–ø–∞–¥–∞—é—â–∏–µ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞
    func matchKeywords(_ text: String) -> [String] {
        let normalized = text.lowercased()
        var matched: [String] = []
        
        for pattern in travelPatterns {
            for keyword in pattern.keywords {
                if normalized.contains(keyword) {
                    matched.append(keyword)
                }
            }
        }
        
        return Array(Set(matched)) // —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ
    }
    
    // –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è (0.0 - 1.0)
    func calculateRelevance(_ text: String) -> Double {
        let normalized = text.lowercased()
        var score = 0.0
        
        // –ë–∞–∑–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –≤–æ–ø—Ä–æ—Å
        if isQuestion(normalized) {
            score += 0.3
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
        for pattern in travelPatterns {
            for keyword in pattern.keywords {
                if normalized.contains(keyword) {
                    score += pattern.weight * 0.1
                }
            }
        }
        
        // –ë–æ–Ω—É—Å –∑–∞ –¥–ª–∏–Ω—É (—Ä–∞–∑–≤—ë—Ä–Ω—É—Ç—ã–µ –≤–æ–ø—Ä–æ—Å—ã –ª—É—á—à–µ)
        let wordCount = normalized.split(separator: " ").count
        if wordCount > 5 && wordCount < 50 {
            score += 0.2
        }
        
        return min(score, 1.0)
    }
    
    // –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –≤–æ–ø—Ä–æ—Å–∞
    func detectCategory(_ text: String) -> String? {
        let normalized = text.lowercased()
        var bestMatch: (category: String, score: Double) = ("unknown", 0.0)
        
        for pattern in travelPatterns {
            var score = 0.0
            for keyword in pattern.keywords {
                if normalized.contains(keyword) {
                    score += pattern.weight
                }
            }
            
            if score > bestMatch.score {
                bestMatch = (pattern.category, score)
            }
        }
        
        return bestMatch.score > 0 ? bestMatch.category : nil
    }
}
```

### –®–∞–≥ 7: AI Reply Service

#### AIReplyService.swift
```swift
import Vapor

final class AIReplyService {
    private let client: Client
    private let apiKey: String
    private let logger: Logger
    private let botUsername: String
    
    init(
        client: Client,
        apiKey: String,
        botUsername: String,
        logger: Logger
    ) {
        self.client = client
        self.apiKey = apiKey
        self.botUsername = botUsername
        self.logger = logger
    }
    
    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞ —á–µ—Ä–µ–∑ Claude AI
    func generateReply(
        question: String,
        context: QuestionContext
    ) async throws -> String {
        let prompt = buildPrompt(question: question, context: context)
        
        let url = URI(string: "https://api.anthropic.com/v1/messages")
        
        var request = ClientRequest(method: .POST, url: url)
        request.headers.add(name: "x-api-key", value: apiKey)
        request.headers.add(name: "anthropic-version", value: "2023-06-01")
        request.headers.add(name: .contentType, value: "application/json")
        
        let body: [String: Any] = [
            "model": "claude-sonnet-4-20250514",
            "max_tokens": 300,
            "messages": [
                [
                    "role": "user",
                    "content": prompt
                ]
            ]
        ]
        
        request.body = .init(data: try JSONSerialization.data(withJSONObject: body))
        
        let response = try await client.send(request)
        
        struct ClaudeResponse: Codable {
            struct Content: Codable {
                let text: String
            }
            let content: [Content]
        }
        
        let aiResponse = try response.content.decode(ClaudeResponse.self)
        let generatedText = aiResponse.content.first?.text ?? ""
        
        // –î–æ–±–∞–≤–ª—è–µ–º —É–ø–æ–º–∏–Ω–∞–Ω–∏–µ –±–æ—Ç–∞ –≤ –∫–æ–Ω—Ü–µ
        return "\(generatedText)\n\nüí° –ü–æ–ø—Ä–æ–±—É–π—Ç–µ @\(botUsername) ‚Äî –ø–æ–º–æ–∂–µ—Ç –Ω–∞–π—Ç–∏ –ª—É—á—à–∏–µ —Ü–µ–Ω—ã"
    }
    
    // –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø—Ä–æ–º–ø—Ç–∞ –¥–ª—è AI
    private func buildPrompt(question: String, context: QuestionContext) -> String {
        """
        –¢—ã ‚Äî –ø–æ–ª–µ–∑–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫ –≤ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è—Ö Telegram –∫–∞–Ω–∞–ª–∞ –æ –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏—è—Ö.
        
        **–í–æ–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:**
        "\(question)"
        
        **–ö–æ–Ω—Ç–µ–∫—Å—Ç:**
        - –ö–∞—Ç–µ–≥–æ—Ä–∏—è: \(context.category ?? "–æ–±—â–∏–π –≤–æ–ø—Ä–æ—Å")
        - –ö–∞–Ω–∞–ª: \(context.channelName)
        - –¢–µ–º–∞ –ø–æ—Å—Ç–∞: \(context.postTopic ?? "–ø—É—Ç–µ—à–µ—Å—Ç–≤–∏—è")
        
        **–ó–∞–¥–∞—á–∞:**
        –ù–∞–ø–∏—à–∏ –∫–æ—Ä–æ—Ç–∫–∏–π (2-3 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è), –ø–æ–ª–µ–∑–Ω—ã–π –æ—Ç–≤–µ—Ç –Ω–∞ –≤–æ–ø—Ä–æ—Å.
        
        **–ü—Ä–∞–≤–∏–ª–∞:**
        1. –ë—É–¥—å –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–º –∏ —ç–∫—Å–ø–µ—Ä—Ç–Ω—ã–º
        2. –î–∞–≤–∞–π –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Å–æ–≤–µ—Ç, –Ω–µ –≤–æ–¥—É
        3. –ù–ï —É–ø–æ–º–∏–Ω–∞–π –±–æ—Ç–∞ –Ω–∞–ø—Ä—è–º—É—é (—ç—Ç–æ –¥–æ–±–∞–≤–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏)
        4. –ò—Å–ø–æ–ª—å–∑—É–π —ç–º–æ–¥–∑–∏ —É–º–µ—Ä–µ–Ω–Ω–æ (1-2 —à—Ç)
        5. –ü–∏—à–∏ –ø–æ-—Ä—É—Å—Å–∫–∏
        
        **–ü—Ä–∏–º–µ—Ä—ã —Ö–æ—Ä–æ—à–∏—Ö –æ—Ç–≤–µ—Ç–æ–≤:**
        
        –í–æ–ø—Ä–æ—Å: "–ì–¥–µ –Ω–∞–π—Ç–∏ –¥–µ—à–µ–≤—ã–µ –±–∏–ª–µ—Ç—ã –≤ –¢—É—Ä—Ü–∏—é?"
        –û—Ç–≤–µ—Ç: "–°–æ–≤–µ—Ç—É—é –º–æ–Ω–∏—Ç–æ—Ä–∏—Ç—å —Å—Ä–∞–∑—É –Ω–µ—Å–∫–æ–ª—å–∫–æ –∞–≥—Ä–µ–≥–∞—Ç–æ—Ä–æ–≤: Aviasales, Skyscanner, –Ø–Ω–¥–µ–∫—Å –ü—É—Ç–µ—à–µ—Å—Ç–≤–∏—è. –õ—É—á—à–∏–µ —Ü–µ–Ω—ã –æ–±—ã—á–Ω–æ –≤ —Å—Ä–µ–¥—É-—á–µ—Ç–≤–µ—Ä–≥. –ï—â—ë –º–æ–∂–Ω–æ —Å–º–æ—Ç—Ä–µ—Ç—å –Ω–∞ –æ—à–∏–±–æ—á–Ω—ã–µ —Ç–∞—Ä–∏—Ñ—ã ‚Äî –∏–Ω–æ–≥–¥–∞ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –±–∏–ª–µ—Ç—ã –Ω–∞ 50% –¥–µ—à–µ–≤–ª–µ."
        
        –í–æ–ø—Ä–æ—Å: "–°–∫–æ–ª—å–∫–æ —Å—Ç–æ–∏—Ç —Å–ª–µ—Ç–∞—Ç—å –≤ –ì—Ä—É–∑–∏—é?"
        –û—Ç–≤–µ—Ç: "–†–µ–∞–ª—å–Ω–æ —É–ª–æ–∂–∏—Ç—å—Å—è –≤ 15-20 —Ç—ã—Å—è—á –Ω–∞ –Ω–µ–¥–µ–ª—é: –±–∏–ª–µ—Ç—ã 6-8–∫, –∂–∏–ª—å—ë 300-500‚ÇΩ/–¥–µ–Ω—å, –µ–¥–∞ 500‚ÇΩ/–¥–µ–Ω—å. –í –º–µ–∂—Å–µ–∑–æ–Ω –µ—â—ë –¥–µ—à–µ–≤–ª–µ. –ì—Ä—É–∑–∏—è ‚Äî –æ–¥–∏–Ω –∏–∑ —Å–∞–º—ã—Ö –±—é–¥–∂–µ—Ç–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –¥–ª—è —Ä–æ—Å—Å–∏—è–Ω üòä"
        
        –¢–µ–ø–µ—Ä—å –æ—Ç–≤–µ—Ç—å –Ω–∞ –≤–æ–ø—Ä–æ—Å –≤—ã—à–µ:
        """
    }
}

struct QuestionContext {
    let category: String?
    let channelName: String
    let postTopic: String?
    let keywordsMatched: [String]
}
```

### –®–∞–≥ 8: Comment Poster Service (—Å –∞–Ω—Ç–∏-—Å–ø–∞–º–æ–º)

#### CommentPosterService.swift
```swift
import Vapor
import Fluent

final class CommentPosterService {
    private let telegramClient: TelegramClient
    private let antiSpam: AntiSpamService
    private let db: Database
    private let logger: Logger
    
    init(
        telegramClient: TelegramClient,
        antiSpam: AntiSpamService,
        db: Database,
        logger: Logger
    ) {
        self.telegramClient = telegramClient
        self.antiSpam = antiSpam
        self.db = db
        self.logger = logger
    }
    
    // –û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å –æ—Ç–≤–µ—Ç
    func postReply(
        to comment: Comment,
        withText replyText: String
    ) async throws {
        // 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–Ω—Ç–∏-—Å–ø–∞–º–∞
        guard try await antiSpam.canPost(to: comment) else {
            logger.warning("‚ö†Ô∏è Anti-spam: cannot post reply to comment \(comment.id?.uuidString ?? "unknown")")
            return
        }
        
        // 2. –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ—Å—Ç–µ –∏ –∫–∞–Ω–∞–ª–µ
        let post = try await comment.$post.get(on: db)
        let channel = try await post.$channel.get(on: db)
        
        // 3. –°–ª—É—á–∞–π–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ (–≤—ã–≥–ª—è–¥–∏—Ç –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–µ–µ)
        let delay = TimeInterval.random(in: 30...120) // 30-120 —Å–µ–∫—É–Ω–¥
        logger.info("‚è≥ Waiting \(Int(delay))s before posting reply...")
        try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
        
        // 4. –û—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è
        do {
            let sentMessage = try await telegramClient.sendComment(
                chatId: channel.username,
                replyToMessageId: comment.telegramCommentId,
                text: replyText
            )
            
            // 5. –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ—Ç–≤–µ—Ç–µ
            let reply = Reply()
            reply.$comment.id = try comment.requireID()
            reply.generatedText = replyText
            reply.posted = true
            reply.telegramReplyId = sentMessage.messageId
            reply.postedAt = Date()
            
            try await reply.save(on: db)
            
            // 6. –û–±–Ω–æ–≤–ª—è–µ–º —Ñ–ª–∞–≥ –≤ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏
            comment.replied = true
            try await comment.save(on: db)
            
            // 7. –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –≤ –∞–Ω—Ç–∏-—Å–ø–∞–º–µ
            try await antiSpam.recordPost(to: comment)
            
            logger.info("‚úÖ Reply posted successfully to comment \(comment.id?.uuidString ?? "unknown")")
            
        } catch {
            logger.error("‚ùå Failed to post reply: \(error)")
            throw error
        }
    }
}
```

#### AntiSpamService.swift
```swift
import Vapor
import Fluent

final class AntiSpamService {
    private let db: Database
    private let logger: Logger
    
    // –õ–∏–º–∏—Ç—ã –¥–ª—è –∞–Ω—Ç–∏-—Å–ø–∞–º–∞
    private let maxRepliesPerHour = 5
    private let maxRepliesPerChannel = 10
    private let minTimeBetweenReplies: TimeInterval = 300 // 5 –º–∏–Ω—É—Ç
    private let maxRepliesPerDay = 30
    
    init(db: Database, logger: Logger) {
        self.db = db
        self.logger = logger
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞, –º–æ–∂–Ω–æ –ª–∏ –ø–æ—Å—Ç–∏—Ç—å –æ—Ç–≤–µ—Ç
    func canPost(to comment: Comment) async throws -> Bool {
        let now = Date()
        
        // 1. –ü—Ä–æ–≤–µ—Ä–∫–∞: —É–∂–µ –æ—Ç–≤–µ—á–∞–ª–∏ –Ω–∞ —ç—Ç–æ—Ç –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π?
        if comment.replied {
            logger.warning("Already replied to this comment")
            return false
        }
        
        // 2. –ü—Ä–æ–≤–µ—Ä–∫–∞: –Ω–µ –ø—Ä–µ–≤—ã—à–µ–Ω –ª–∏ –ª–∏–º–∏—Ç –≤ —á–∞—Å?
        let oneHourAgo = now.addingTimeInterval(-3600)
        let repliesLastHour = try await Reply.query(on: db)
            .filter(\.$postedAt > oneHourAgo)
            .count()
        
        if repliesLastHour >= maxRepliesPerHour {
            logger.warning("Hourly limit reached: \(repliesLastHour)/\(maxRepliesPerHour)")
            return false
        }
        
        // 3. –ü—Ä–æ–≤–µ—Ä–∫–∞: –Ω–µ –ø—Ä–µ–≤—ã—à–µ–Ω –ª–∏ –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç?
        let oneDayAgo = now.addingTimeInterval(-86400)
        let repliesToday = try await Reply.query(on: db)
            .filter(\.$postedAt > oneDayAgo)
            .count()
        
        if repliesToday >= maxRepliesPerDay {
            logger.warning("Daily limit reached: \(repliesToday)/\(maxRepliesPerDay)")
            return false
        }
        
        // 4. –ü—Ä–æ–≤–µ—Ä–∫–∞: –ø—Ä–æ—à–ª–æ –ª–∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤—Ä–µ–º–µ–Ω–∏ —Å –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ—Ç–≤–µ—Ç–∞?
        if let lastReply = try await Reply.query(on: db)
            .sort(\.$postedAt, .descending)
            .first() {
            
            if let lastPostedAt = lastReply.postedAt {
                let timeSinceLastPost = now.timeIntervalSince(lastPostedAt)
                if timeSinceLastPost < minTimeBetweenReplies {
                    logger.warning("Too soon since last post: \(Int(timeSinceLastPost))s")
                    return false
                }
            }
        }
        
        // 5. –ü—Ä–æ–≤–µ—Ä–∫–∞: –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –º–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–æ–≤ –≤ —ç—Ç–æ–º –∫–∞–Ω–∞–ª–µ?
        let post = try await comment.$post.get(on: db)
        let channel = try await post.$channel.get(on: db)
        
        let repliesInChannel = try await Reply.query(on: db)
            .join(Comment.self, on: \Reply.$comment.$id == \Comment.$id)
            .join(Post.self, on: \Comment.$post.$id == \Post.$id)
            .filter(Post.self, \.$channel.$id == channel.requireID())
            .filter(\.$postedAt > oneDayAgo)
            .count()
        
        if repliesInChannel >= maxRepliesPerChannel {
            logger.warning("Channel daily limit reached: \(repliesInChannel)/\(maxRepliesPerChannel)")
            return false
        }
        
        return true
    }
    
    // –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–æ–≤—ã–π –æ—Ç–≤–µ—Ç
    func recordPost(to comment: Comment) async throws {
        logger.info("üìù Recorded new reply in anti-spam system")
    }
}
```

### –®–∞–≥ 9: –§–æ–Ω–æ–≤—ã–µ –∑–∞–¥–∞—á–∏ (Jobs)

#### CommentAnalysisJob.swift
```swift
import Vapor
import Queues

struct CommentAnalysisJob: AsyncScheduledJob {
    let commentParser: CommentParserService
    let questionDetector: QuestionDetectorService
    let aiReplyService: AIReplyService
    let commentPoster: CommentPosterService
    
    // –ó–∞–ø—É—Å–∫–∞—Ç—å –∫–∞–∂–¥—ã–µ 10 –º–∏–Ω—É—Ç
    func run(context: QueueContext) async throws {
        context.logger.info("üîç Starting comment analysis job...")
        
        // 1. –ù–∞–π—Ç–∏ –Ω–æ–≤—ã–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –µ—â—ë –Ω–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã
        let unprocessedComments = try await Comment.query(on: context.application.db)
            .filter(\.$replied == false)
            .filter(\.$is_question == false) // –µ—â—ë –Ω–µ –ø—Ä–æ–≤–µ—Ä–∏–ª–∏
            .limit(50)
            .all()
        
        context.logger.info("üìä Found \(unprocessedComments.count) unprocessed comments")
        
        for comment in unprocessedComments {
            // 2. –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ –≤–æ–ø—Ä–æ—Å–æ–º
            let isQuestion = questionDetector.isQuestion(comment.text)
            comment.isQuestion = isQuestion
            
            if !isQuestion {
                try await comment.save(on: context.application.db)
                continue
            }
            
            // 3. –ù–∞–π—Ç–∏ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞
            let keywords = questionDetector.matchKeywords(comment.text)
            comment.keywordsMatched = keywords
            
            // 4. –†–∞—Å—Å—á–∏—Ç–∞—Ç—å —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç—å
            let relevance = questionDetector.calculateRelevance(comment.text)
            
            // 5. –ï—Å–ª–∏ —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç—å –≤—ã—Å–æ–∫–∞—è (> 0.6), –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
            if relevance > 0.6 {
                let post = try await comment.$post.get(on: context.application.db)
                let channel = try await post.$channel.get(on: context.application.db)
                
                let questionContext = QuestionContext(
                    category: questionDetector.detectCategory(comment.text),
                    channelName: channel.title,
                    postTopic: post.text.prefix(100).description,
                    keywordsMatched: keywords
                )
                
                // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
                let replyText = try await aiReplyService.generateReply(
                    question: comment.text,
                    context: questionContext
                )
                
                // –°–æ–∑–¥–∞—ë–º –∑–∞–ø–∏—Å—å –æ–± –æ—Ç–≤–µ—Ç–µ (–Ω–æ –Ω–µ –ø—É–±–ª–∏–∫—É–µ–º —Å—Ä–∞–∑—É)
                let reply = Reply()
                reply.$comment.id = try comment.requireID()
                reply.generatedText = replyText
                reply.posted = false
                
                try await reply.save(on: context.application.db)
                
                context.logger.info("‚úÖ Generated reply for comment \(comment.id?.uuidString ?? "unknown")")
            }
            
            try await comment.save(on: context.application.db)
        }
        
        context.logger.info("‚úÖ Comment analysis job completed")
    }
}
```

#### ReplyPostingJob.swift
```swift
import Vapor
import Queues

struct ReplyPostingJob: AsyncScheduledJob {
    let commentPoster: CommentPosterService
    
    // –ó–∞–ø—É—Å–∫–∞—Ç—å –∫–∞–∂–¥—ã–µ 15 –º–∏–Ω—É—Ç
    func run(context: QueueContext) async throws {
        context.logger.info("üì§ Starting reply posting job...")
        
        // 1. –ù–∞–π—Ç–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ, –Ω–æ –Ω–µ –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã
        let pendingReplies = try await Reply.query(on: context.application.db)
            .filter(\.$posted == false)
            .limit(10)
            .all()
        
        context.logger.info("üìä Found \(pendingReplies.count) pending replies")
        
        for reply in pendingReplies {
            let comment = try await reply.$comment.get(on: context.application.db)
            
            do {
                // 2. –ü–æ–ø—ã—Ç–∞—Ç—å—Å—è –æ–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å
                try await commentPoster.postReply(
                    to: comment,
                    withText: reply.generatedText
                )
                
                context.logger.info("‚úÖ Posted reply \(reply.id?.uuidString ?? "unknown")")
                
            } catch {
                context.logger.error("‚ùå Failed to post reply: \(error)")
                
                // –ï—Å–ª–∏ –æ—à–∏–±–∫–∞, –ø–æ–º–µ—Ç–∏–º –∫–∞–∫ –Ω–µ—É–¥–∞—á–Ω—É—é –ø–æ–ø—ã—Ç–∫—É
                // (–º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Å—á—ë—Ç—á–∏–∫ –ø–æ–ø—ã—Ç–æ–∫)
            }
        }
        
        context.logger.info("‚úÖ Reply posting job completed")
    }
}
```

### –®–∞–≥ 10: Configuration

#### configure.swift
```swift
import Vapor
import Fluent
import FluentPostgresDriver
import Queues

public func configure(_ app: Application) async throws {
    // MARK: - Database
    guard let databaseURL = Environment.get("DATABASE_URL") else {
        fatalError("DATABASE_URL not set")
    }
    
    try app.databases.use(.postgres(url: databaseURL), as: .psql)
    
    // MARK: - Migrations
    app.migrations.add(CreateChannels())
    app.migrations.add(CreatePosts())
    app.migrations.add(CreateComments())
    app.migrations.add(CreateReplies())
    
    try await app.autoMigrate()
    
    // MARK: - Services
    let botToken = Environment.get("TELEGRAM_BOT_TOKEN")!
    let claudeApiKey = Environment.get("CLAUDE_API_KEY")!
    let botUsername = Environment.get("BOT_USERNAME") ?? "gdeTravel_bot"
    
    let telegramClient = TelegramClient(
        client: app.client,
        botToken: botToken,
        logger: app.logger
    )
    
    let questionDetector = QuestionDetectorService(logger: app.logger)
    
    let aiReplyService = AIReplyService(
        client: app.client,
        apiKey: claudeApiKey,
        botUsername: botUsername,
        logger: app.logger
    )
    
    let antiSpam = AntiSpamService(db: app.db, logger: app.logger)
    
    let commentPoster = CommentPosterService(
        telegramClient: telegramClient,
        antiSpam: antiSpam,
        db: app.db,
        logger: app.logger
    )
    
    // MARK: - Queues (—Ñ–æ–Ω–æ–≤—ã–µ –∑–∞–¥–∞—á–∏)
    try app.queues.use(.memory)
    
    // –ê–Ω–∞–ª–∏–∑ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤ –∫–∞–∂–¥—ã–µ 10 –º–∏–Ω—É—Ç
    app.queues.schedule(
        CommentAnalysisJob(
            commentParser: CommentParserService(),
            questionDetector: questionDetector,
            aiReplyService: aiReplyService,
            commentPoster: commentPoster
        )
    )
    .minutely()
    .at(0, 10, 20, 30, 40, 50)
    
    // –ü—É–±–ª–∏–∫–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–æ–≤ –∫–∞–∂–¥—ã–µ 15 –º–∏–Ω—É—Ç
    app.queues.schedule(
        ReplyPostingJob(commentPoster: commentPoster)
    )
    .minutely()
    .at(5, 20, 35, 50)
    
    try app.queues.startScheduledJobs()
    
    // MARK: - Routes
    try routes(app)
}
```

### –®–∞–≥ 11: Environment —Ñ–∞–π–ª

#### .env.example
```bash
# Database
DATABASE_URL=postgres://user:password@localhost:5432/comment_bot

# Telegram
TELEGRAM_BOT_TOKEN=your_bot_token_here
BOT_USERNAME=gdeTravel_bot

# Claude AI
CLAUDE_API_KEY=your_claude_api_key_here

# Server
PORT=8080
LOG_LEVEL=info

# Monitoring
ENABLE_METRICS=true
```

---

## üîí –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ –∞–Ω—Ç–∏-–±–∞–Ω –º–µ—Ä—ã

### 1. Rate Limiting
```swift
// –í AntiSpamService.swift —É–∂–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ:
- –ú–∞–∫—Å–∏–º—É–º 5 –æ—Ç–≤–µ—Ç–æ–≤ –≤ —á–∞—Å
- –ú–∞–∫—Å–∏–º—É–º 30 –æ—Ç–≤–µ—Ç–æ–≤ –≤ –¥–µ–Ω—å
- –ú–∏–Ω–∏–º—É–º 5 –º–∏–Ω—É—Ç –º–µ–∂–¥—É –æ—Ç–≤–µ—Ç–∞–º–∏
- –ú–∞–∫—Å–∏–º—É–º 10 –æ—Ç–≤–µ—Ç–æ–≤ –Ω–∞ –∫–∞–Ω–∞–ª –≤ –¥–µ–Ω—å
```

### 2. –°–ª—É—á–∞–π–Ω—ã–µ –∑–∞–¥–µ—Ä–∂–∫–∏
```swift
// –í—ã–≥–ª—è–¥–∏—Ç –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–µ–µ
let delay = TimeInterval.random(in: 30...120) // 30-120 —Å–µ–∫—É–Ω–¥
try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
```

### 3. –í–∞—Ä–∏–∞—Ü–∏—è —Ç–µ–∫—Å—Ç–æ–≤
```swift
// –î–æ–±–∞–≤–∏—Ç—å –≤ AIReplyService –≤–∞—Ä–∏–∞—Ü–∏–∏ —Ñ—Ä–∞–∑
let botMentions = [
    "üí° –ü–æ–ø—Ä–æ–±—É–π—Ç–µ @\(botUsername)",
    "ü§ñ –ö—Å—Ç–∞—Ç–∏, @\(botUsername) –ø–æ–º–æ–∂–µ—Ç",
    "‚úàÔ∏è –°–æ–≤–µ—Ç—É—é –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å @\(botUsername)",
    "üì± –ï—â—ë –µ—Å—Ç—å @\(botUsername) –¥–ª—è —Ç–∞–∫–∏—Ö –∑–∞–¥–∞—á"
]

let randomMention = botMentions.randomElement()!
return "\(generatedText)\n\n\(randomMention)"
```

### 4. –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã
```swift
// –í CommentAnalysisJob –¥–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É
let similarComments = try await Comment.query(on: db)
    .filter(\.$text == comment.text)
    .filter(\.$replied == true)
    .count()

if similarComments > 0 {
    continue // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç
}
```

---

## üöÄ –î–µ–ø–ª–æ–π

### Docker

#### Dockerfile
```dockerfile
FROM swift:5.9-jammy as build

WORKDIR /build

# –ö–æ–ø–∏—Ä—É–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
COPY Package.* ./
RUN swift package resolve

# –ö–æ–ø–∏—Ä—É–µ–º –∏—Å—Ö–æ–¥–Ω–∏–∫–∏
COPY . .

# –°–æ–±–∏—Ä–∞–µ–º
RUN swift build -c release --static-swift-stdlib

# Production stage
FROM ubuntu:jammy

# –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º runtime –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
RUN apt-get update -y \
    && apt-get install -y libpq-dev \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# –ö–æ–ø–∏—Ä—É–µ–º –±–∏–Ω–∞—Ä–Ω–∏–∫
COPY --from=build /build/.build/release/App ./

EXPOSE 8080

ENTRYPOINT ["./App"]
CMD ["serve", "--env", "production", "--hostname", "0.0.0.0", "--port", "8080"]
```

#### docker-compose.yml
```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      DATABASE_URL: postgres://comment_bot:password@db:5432/comment_bot
      TELEGRAM_BOT_TOKEN: ${TELEGRAM_BOT_TOKEN}
      BOT_USERNAME: ${BOT_USERNAME}
      CLAUDE_API_KEY: ${CLAUDE_API_KEY}
    depends_on:
      - db
    restart: unless-stopped
    
  db:
    image: postgres:15
    environment:
      POSTGRES_DB: comment_bot
      POSTGRES_USER: comment_bot
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

volumes:
  postgres_data:
```

### Railway Deploy

```bash
# 1. –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç –Ω–∞ Railway
railway init

# 2. –î–æ–±–∞–≤–∏—Ç—å PostgreSQL
railway add postgres

# 3. –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
railway variables set TELEGRAM_BOT_TOKEN=your_token
railway variables set CLAUDE_API_KEY=your_key
railway variables set BOT_USERNAME=gdeTravel_bot

# 4. –ó–∞–¥–µ–ø–ª–æ–∏—Ç—å
railway up
```

---

## üìä –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥

### API –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏

#### routes.swift
```swift
import Vapor

func routes(_ app: Application) throws {
    // Health check
    app.get("health") { req in
        return ["status": "ok"]
    }
    
    // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    app.get("stats") { req async throws -> StatsResponse in
        let totalChannels = try await Channel.query(on: req.db).count()
        let activeChannels = try await Channel.query(on: req.db)
            .filter(\.$isActive == true)
            .count()
        
        let totalComments = try await Comment.query(on: req.db).count()
        let questions = try await Comment.query(on: req.db)
            .filter(\.$isQuestion == true)
            .count()
        
        let totalReplies = try await Reply.query(on: req.db).count()
        let postedReplies = try await Reply.query(on: req.db)
            .filter(\.$posted == true)
            .count()
        
        let today = Date().addingTimeInterval(-86400)
        let repliesToday = try await Reply.query(on: req.db)
            .filter(\.$postedAt > today)
            .count()
        
        return StatsResponse(
            channels: ChannelStats(total: totalChannels, active: activeChannels),
            comments: CommentStats(total: totalComments, questions: questions),
            replies: ReplyStats(
                total: totalReplies,
                posted: postedReplies,
                today: repliesToday
            )
        )
    }
}

struct StatsResponse: Content {
    struct ChannelStats: Content {
        let total: Int
        let active: Int
    }
    
    struct CommentStats: Content {
        let total: Int
        let questions: Int
    }
    
    struct ReplyStats: Content {
        let total: Int
        let posted: Int
        let today: Int
    }
    
    let channels: ChannelStats
    let comments: CommentStats
    let replies: ReplyStats
}
```

---

## üìù –§–∏–Ω–∞–ª—å–Ω—ã–π —á–µ–∫–ª–∏—Å—Ç

### –ü–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º:

- [ ] –°–æ–∑–¥–∞—Ç—å Telegram –±–æ—Ç–∞ —á–µ—Ä–µ–∑ @BotFather
- [ ] –ü–æ–ª—É—á–∏—Ç—å —Ç–æ–∫–µ–Ω Claude API
- [ ] –ù–∞—Å—Ç—Ä–æ–∏—Ç—å PostgreSQL
- [ ] –î–æ–±–∞–≤–∏—Ç—å –±–æ—Ç–∞ –≤ —Ü–µ–ª–µ–≤—ã–µ –∫–∞–Ω–∞–ª—ã (–∫–∞–∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞)
- [ ] –ó–∞–ø–æ–ª–Ω–∏—Ç—å .env —Ñ–∞–π–ª
- [ ] –ó–∞–ø—É—Å—Ç–∏—Ç—å –º–∏–≥—Ä–∞—Ü–∏–∏ –ë–î
- [ ] –ü—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ 1-2 –∫–∞–Ω–∞–ª–∞—Ö
- [ ] –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥

### –ü–æ—Å–ª–µ –∑–∞–ø—É—Å–∫–∞:

- [ ] –û—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –º–µ—Ç—Ä–∏–∫–∏ –æ—Ç–≤–µ—Ç–æ–≤
- [ ] –ü—Ä–æ–≤–µ—Ä—è—Ç—å –∫–∞—á–µ—Å—Ç–≤–æ –æ—Ç–≤–µ—Ç–æ–≤ AI
- [ ] –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ª–∏–º–∏—Ç—ã –∞–Ω—Ç–∏-—Å–ø–∞–º–∞
- [ ] –î–æ–±–∞–≤–ª—è—Ç—å –Ω–æ–≤—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã –≤–æ–ø—Ä–æ—Å–æ–≤
- [ ] –°–æ–±–∏—Ä–∞—Ç—å feedback –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π

---

## üéØ –°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏

1. **–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –∫–∞–Ω–∞–ª–æ–≤**
   ```swift
   // –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å ChannelDiscoveryService
   // –ü–∞—Ä—Å–∏—Ç—å Telegram –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º: "–ø—É—Ç–µ—à–µ—Å—Ç–≤–∏—è", "—Ç—É—Ä–∏–∑–º"
   ```

2. **Sentiment Analysis**
   ```swift
   // –ê–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Ç–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å –≤–æ–ø—Ä–æ—Å–æ–≤
   // –û—Ç–≤–µ—á–∞—Ç—å —Ç–æ–ª—å–∫–æ –Ω–∞ –ø–æ–∑–∏—Ç–∏–≤–Ω—ã–µ/–Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–µ
   ```

3. **A/B —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–≤–µ—Ç–æ–≤**
   ```swift
   // –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å 2-3 –≤–∞—Ä–∏–∞–Ω—Ç–∞ –æ—Ç–≤–µ—Ç–∞
   // –í—ã–±–∏—Ä–∞—Ç—å –ª—É—á—à–∏–π –ø–æ –º–µ—Ç—Ä–∏–∫–∞–º
   ```

4. **Dashboard**
   ```typescript
   // Next.js –∞–¥–º–∏–Ω–∫–∞ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
   // –ì—Ä–∞—Ñ–∏–∫–∏, —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞, —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–∞–º–∏
   ```

---

## üí° –ü–æ–ª–µ–∑–Ω—ã–µ —Å—Å—ã–ª–∫–∏

- [Telegram Bot API](https://core.telegram.org/bots/api)
- [Claude API Docs](https://docs.anthropic.com/)
- [Vapor Framework](https://docs.vapor.codes/)
- [Fluent ORM](https://docs.vapor.codes/fluent/overview/)

---

**–ì–æ—Ç–æ–≤–æ –∫ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ!** üöÄ

–°–æ–∑–¥–∞–≤–∞–π –Ω–æ–≤—ã–π —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π, –∫–æ–ø–∏—Ä—É–π —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∏ –Ω–∞—á–∏–Ω–∞–π –∫–æ–¥–∏—Ç—å!

